{"project": "csp-benchmarks", "project_url": "https://github.com/csp-community/csp-benchmarks", "show_commit_url": "#", "hash_length": 8, "revision_to_hash": {"4": "01ce9cfc968e06cdfa0a740a5877ede729be0fe7"}, "revision_to_date": {"4": 1765672326000}, "params": {"arch": ["arm64", "x86_64"], "cpu": ["AMD Ryzen AI 9 HX 370 (24 cores)", "Apple M2 (8 cores)"], "machine": ["timkpaine-framework-13", "timkpaine-mbp-m2"], "num_cpu": ["24", "8"], "os": ["Ubuntu 24.04", "macOS"], "ram": ["16GB", "64GB"], "python": ["3.11", "3.12", "3.13"], "csp": ["0.12.0", "0.13.0", "0.13.1", "0.13.2", "0.14.0"], "branch": ["main"]}, "graph_param_list": [{"arch": "arm64", "cpu": "Apple M2 (8 cores)", "machine": "timkpaine-mbp-m2", "num_cpu": "8", "os": "macOS", "ram": "16GB", "python": "3.13", "csp": "0.13.1", "branch": "main"}, {"arch": "arm64", "cpu": "Apple M2 (8 cores)", "machine": "timkpaine-mbp-m2", "num_cpu": "8", "os": "macOS", "ram": "16GB", "python": "3.12", "csp": "0.13.1", "branch": "main"}, {"arch": "arm64", "cpu": "Apple M2 (8 cores)", "machine": "timkpaine-mbp-m2", "num_cpu": "8", "os": "macOS", "ram": "16GB", "python": "3.11", "csp": "0.13.2", "branch": "main"}, {"arch": "arm64", "cpu": "Apple M2 (8 cores)", "machine": "timkpaine-mbp-m2", "num_cpu": "8", "os": "macOS", "ram": "16GB", "python": "3.13", "csp": "0.13.2", "branch": "main"}, {"arch": "arm64", "cpu": "Apple M2 (8 cores)", "machine": "timkpaine-mbp-m2", "num_cpu": "8", "os": "macOS", "ram": "16GB", "python": "3.12", "csp": "0.12.0", "branch": "main"}, {"arch": "arm64", "cpu": "Apple M2 (8 cores)", "machine": "timkpaine-mbp-m2", "num_cpu": "8", "os": "macOS", "ram": "16GB", "python": "3.11", "csp": "0.13.0", "branch": "main"}, {"arch": "arm64", "cpu": "Apple M2 (8 cores)", "machine": "timkpaine-mbp-m2", "num_cpu": "8", "os": "macOS", "ram": "16GB", "python": "3.13", "csp": "0.14.0", "branch": "main"}, {"arch": "arm64", "cpu": "Apple M2 (8 cores)", "machine": "timkpaine-mbp-m2", "num_cpu": "8", "os": "macOS", "ram": "16GB", "python": "3.11", "csp": "0.12.0", "branch": "main"}, {"arch": "arm64", "cpu": "Apple M2 (8 cores)", "machine": "timkpaine-mbp-m2", "num_cpu": "8", "os": "macOS", "ram": "16GB", "python": "3.12", "csp": "0.13.0", "branch": "main"}, {"arch": "arm64", "cpu": "Apple M2 (8 cores)", "machine": "timkpaine-mbp-m2", "num_cpu": "8", "os": "macOS", "ram": "16GB", "python": "3.11", "csp": "0.14.0", "branch": "main"}, {"arch": "arm64", "cpu": "Apple M2 (8 cores)", "machine": "timkpaine-mbp-m2", "num_cpu": "8", "os": "macOS", "ram": "16GB", "python": "3.13", "csp": "0.12.0", "branch": "main"}, {"arch": "arm64", "cpu": "Apple M2 (8 cores)", "machine": "timkpaine-mbp-m2", "num_cpu": "8", "os": "macOS", "ram": "16GB", "python": "3.11", "csp": "0.13.1", "branch": "main"}, {"arch": "arm64", "cpu": "Apple M2 (8 cores)", "machine": "timkpaine-mbp-m2", "num_cpu": "8", "os": "macOS", "ram": "16GB", "python": "3.13", "csp": "0.13.0", "branch": "main"}, {"arch": "arm64", "cpu": "Apple M2 (8 cores)", "machine": "timkpaine-mbp-m2", "num_cpu": "8", "os": "macOS", "ram": "16GB", "python": "3.12", "csp": "0.13.2", "branch": "main"}, {"arch": "arm64", "cpu": "Apple M2 (8 cores)", "machine": "timkpaine-mbp-m2", "num_cpu": "8", "os": "macOS", "ram": "16GB", "python": "3.12", "csp": "0.14.0", "branch": "main"}, {"arch": "x86_64", "cpu": "AMD Ryzen AI 9 HX 370 (24 cores)", "machine": "timkpaine-framework-13", "num_cpu": "24", "os": "Ubuntu 24.04", "ram": "64GB", "python": "3.12", "csp": "0.13.1", "branch": "main"}, {"arch": "x86_64", "cpu": "AMD Ryzen AI 9 HX 370 (24 cores)", "machine": "timkpaine-framework-13", "num_cpu": "24", "os": "Ubuntu 24.04", "ram": "64GB", "python": "3.12", "csp": "0.12.0", "branch": "main"}, {"arch": "x86_64", "cpu": "AMD Ryzen AI 9 HX 370 (24 cores)", "machine": "timkpaine-framework-13", "num_cpu": "24", "os": "Ubuntu 24.04", "ram": "64GB", "python": "3.12", "csp": "0.13.0", "branch": "main"}, {"arch": "x86_64", "cpu": "AMD Ryzen AI 9 HX 370 (24 cores)", "machine": "timkpaine-framework-13", "num_cpu": "24", "os": "Ubuntu 24.04", "ram": "64GB", "python": "3.12", "csp": "0.13.2", "branch": "main"}, {"arch": "x86_64", "cpu": "AMD Ryzen AI 9 HX 370 (24 cores)", "machine": "timkpaine-framework-13", "num_cpu": "24", "os": "Ubuntu 24.04", "ram": "64GB", "python": "3.12", "csp": "0.14.0", "branch": "main"}], "benchmarks": {"bench_baselib.BaselibSuite.time_delay": {"code": "class BaselibSuite:\n    def time_delay(self, num_ticks):\n        \"\"\"Benchmark csp.delay operation.\"\"\"\n    \n        @csp.graph\n        def graph():\n            timer = csp.timer(timedelta(seconds=1), 1.0)\n            delayed = csp.delay(timer, timedelta(seconds=5))\n            csp.add_graph_output(\"output\", delayed)\n    \n        csp.run(graph, starttime=self.start_time, endtime=self.end_time, realtime=False)\n\n    def setup(self, num_ticks):\n        self.start_time = datetime(2020, 1, 1)\n        self.end_time = self.start_time + timedelta(seconds=num_ticks)", "min_run_count": 2, "name": "bench_baselib.BaselibSuite.time_delay", "number": 0, "param_names": ["num_ticks"], "params": [["1000", "10000", "100000"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "19d0e882be4ba12ee7bfff021c705c4fe5d5d7c448d6259c1b11f31f30ef69f7", "warmup_time": -1}, "bench_baselib.BaselibSuite.time_filter": {"code": "class BaselibSuite:\n    def time_filter(self, num_ticks):\n        \"\"\"Benchmark csp.filter operation.\"\"\"\n    \n        @csp.graph\n        def graph():\n            timer = csp.timer(timedelta(seconds=1), 1.0)\n            counter = csp.count(timer)\n            # Filter to only even counts\n            is_even = csp.apply(counter, lambda x: x % 2 == 0, bool)\n            filtered = csp.filter(is_even, timer)\n            csp.add_graph_output(\"output\", filtered)\n    \n        csp.run(graph, starttime=self.start_time, endtime=self.end_time, realtime=False)\n\n    def setup(self, num_ticks):\n        self.start_time = datetime(2020, 1, 1)\n        self.end_time = self.start_time + timedelta(seconds=num_ticks)", "min_run_count": 2, "name": "bench_baselib.BaselibSuite.time_filter", "number": 0, "param_names": ["num_ticks"], "params": [["1000", "10000", "100000"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "2ac032303b2c487dd23100267f94df9048bcc1ff651a7c4f51eb55dc6382f7f0", "warmup_time": -1}, "bench_baselib.BaselibSuite.time_flatten": {"code": "class BaselibSuite:\n    def time_flatten(self, num_ticks):\n        \"\"\"Benchmark csp.flatten operation.\"\"\"\n    \n        @csp.graph\n        def graph():\n            timer1 = csp.timer(timedelta(seconds=1), 1.0)\n            timer2 = csp.timer(timedelta(seconds=2), 2.0)\n            timer3 = csp.timer(timedelta(seconds=3), 3.0)\n            flattened = csp.flatten([timer1, timer2, timer3])\n            csp.add_graph_output(\"output\", flattened)\n    \n        csp.run(graph, starttime=self.start_time, endtime=self.end_time, realtime=False)\n\n    def setup(self, num_ticks):\n        self.start_time = datetime(2020, 1, 1)\n        self.end_time = self.start_time + timedelta(seconds=num_ticks)", "min_run_count": 2, "name": "bench_baselib.BaselibSuite.time_flatten", "number": 0, "param_names": ["num_ticks"], "params": [["1000", "10000", "100000"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "fa5a18128762bf240524618223bb056b1b0919d1fce2cfe41c8258e8136b8c78", "warmup_time": -1}, "bench_baselib.BaselibSuite.time_merge": {"code": "class BaselibSuite:\n    def time_merge(self, num_ticks):\n        \"\"\"Benchmark csp.merge operation.\"\"\"\n    \n        @csp.graph\n        def graph():\n            t1 = csp.timer(timedelta(seconds=1), 1.0)\n            t2 = csp.timer(timedelta(seconds=2), 2.0)\n            t3 = csp.timer(timedelta(seconds=3), 3.0)\n            merged = csp.merge(t1, t2, t3)\n            csp.add_graph_output(\"output\", merged)\n    \n        csp.run(graph, starttime=self.start_time, endtime=self.end_time, realtime=False)\n\n    def setup(self, num_ticks):\n        self.start_time = datetime(2020, 1, 1)\n        self.end_time = self.start_time + timedelta(seconds=num_ticks)", "min_run_count": 2, "name": "bench_baselib.BaselibSuite.time_merge", "number": 0, "param_names": ["num_ticks"], "params": [["1000", "10000", "100000"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "b95dd5b7cf5acc86d9000280fa80ea137f6ab7c5a69d54b7e917f1fa2a835a76", "warmup_time": -1}, "bench_baselib.BaselibSuite.time_sample": {"code": "class BaselibSuite:\n    def time_sample(self, num_ticks):\n        \"\"\"Benchmark csp.sample operation.\"\"\"\n    \n        @csp.graph\n        def graph():\n            fast_timer = csp.timer(timedelta(seconds=1), 1.0)\n            slow_trigger = csp.timer(timedelta(seconds=10), True)\n            sampled = csp.sample(slow_trigger, fast_timer)\n            csp.add_graph_output(\"output\", sampled)\n    \n        csp.run(graph, starttime=self.start_time, endtime=self.end_time, realtime=False)\n\n    def setup(self, num_ticks):\n        self.start_time = datetime(2020, 1, 1)\n        self.end_time = self.start_time + timedelta(seconds=num_ticks)", "min_run_count": 2, "name": "bench_baselib.BaselibSuite.time_sample", "number": 0, "param_names": ["num_ticks"], "params": [["1000", "10000", "100000"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "463c8df0cdca5a9a74576fa6bab255dba9b4a5b0986e564b2139552d1e29d100", "warmup_time": -1}, "bench_baselib.CurveSuite.time_curve_load": {"code": "class CurveSuite:\n    def time_curve_load(self, num_points):\n        \"\"\"Benchmark loading data via csp.curve.\"\"\"\n    \n        @csp.graph\n        def graph():\n            data = csp.curve(float, self.data)\n            csp.add_graph_output(\"output\", data)\n    \n        csp.run(graph, starttime=self.start_time, endtime=self.end_time, realtime=False)\n\n    def setup(self, num_points):\n        self.start_time = datetime(2020, 1, 1)\n        self.end_time = self.start_time + timedelta(seconds=num_points)\n        # Pre-generate the curve data\n        self.data = [(self.start_time + timedelta(seconds=i), float(i)) for i in range(num_points)]", "min_run_count": 2, "name": "bench_baselib.CurveSuite.time_curve_load", "number": 0, "param_names": ["num_points"], "params": [["100", "1000", "10000"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "a2b95a799a0966c31fa0830dc3152f85c9d04560cdcfb5f5e1f07cd0d2742ac7", "warmup_time": -1}, "bench_baselib.CurveSuite.time_curve_with_processing": {"code": "class CurveSuite:\n    def time_curve_with_processing(self, num_points):\n        \"\"\"Benchmark loading and processing curve data.\"\"\"\n    \n        @csp.node\n        def process(x: csp.ts[float]) -> csp.ts[float]:\n            if csp.ticked(x):\n                return x * 2.0\n    \n        @csp.graph\n        def graph():\n            data = csp.curve(float, self.data)\n            processed = process(data)\n            csp.add_graph_output(\"output\", processed)\n    \n        csp.run(graph, starttime=self.start_time, endtime=self.end_time, realtime=False)\n\n    def setup(self, num_points):\n        self.start_time = datetime(2020, 1, 1)\n        self.end_time = self.start_time + timedelta(seconds=num_points)\n        # Pre-generate the curve data\n        self.data = [(self.start_time + timedelta(seconds=i), float(i)) for i in range(num_points)]", "min_run_count": 2, "name": "bench_baselib.CurveSuite.time_curve_with_processing", "number": 0, "param_names": ["num_points"], "params": [["100", "1000", "10000"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "15b394c06356a66e8e8e2bdd2047acdb77369d8b622fcd0aec6fd3176b73cfa6", "warmup_time": -1}, "bench_core.GraphExecutionSuite.time_fan_in_graph": {"code": "class GraphExecutionSuite:\n    def time_fan_in_graph(self, num_nodes, num_ticks):\n        \"\"\"Time a graph with many sources merging into one.\"\"\"\n    \n        @csp.node\n        def summer(xs: [csp.ts[float]]) -> csp.ts[float]:\n            return sum(x for x in xs if csp.ticked(x))\n    \n        @csp.graph\n        def fan_in_graph():\n            sources = [csp.timer(timedelta(seconds=1), float(i)) for i in range(num_nodes)]\n            result = csp.merge(*sources)\n            csp.add_graph_output(\"output\", result)\n    \n        csp.run(fan_in_graph, starttime=self.start_time, endtime=self.end_time, realtime=False)\n\n    def setup(self, num_nodes, num_ticks):\n        self.start_time = datetime(2020, 1, 1)\n        self.end_time = self.start_time + timedelta(seconds=num_ticks)", "min_run_count": 2, "name": "bench_core.GraphExecutionSuite.time_fan_in_graph", "number": 0, "param_names": ["num_nodes", "num_ticks"], "params": [["10", "100", "1000"], ["100", "1000", "10000"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "f20ad5171a51ecb7f63676aed81eca99e2fba21ae4111c7bc1a0a5522eccb7ec", "warmup_time": -1}, "bench_core.GraphExecutionSuite.time_fan_out_graph": {"code": "class GraphExecutionSuite:\n    def time_fan_out_graph(self, num_nodes, num_ticks):\n        \"\"\"Time a graph with one source fanning out to many nodes.\"\"\"\n    \n        @csp.node\n        def consumer(x: csp.ts[float]) -> csp.ts[float]:\n            if csp.ticked(x):\n                return x * 2\n    \n        @csp.graph\n        def fan_out_graph():\n            timer = csp.timer(timedelta(seconds=1), 1.0)\n    \n            for i in range(num_nodes):\n                result = consumer(timer)\n                csp.add_graph_output(f\"output_{i}\", result)\n    \n        csp.run(fan_out_graph, starttime=self.start_time, endtime=self.end_time, realtime=False)\n\n    def setup(self, num_nodes, num_ticks):\n        self.start_time = datetime(2020, 1, 1)\n        self.end_time = self.start_time + timedelta(seconds=num_ticks)", "min_run_count": 2, "name": "bench_core.GraphExecutionSuite.time_fan_out_graph", "number": 0, "param_names": ["num_nodes", "num_ticks"], "params": [["10", "100", "1000"], ["100", "1000", "10000"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "9170ff83de39d13f62716cfa4a64c1e0258b307ab61e4aba448090637f5d6787", "warmup_time": -1}, "bench_core.GraphExecutionSuite.time_linear_graph": {"code": "class GraphExecutionSuite:\n    def time_linear_graph(self, num_nodes, num_ticks):\n        \"\"\"Time a linear chain of nodes passing data through.\"\"\"\n    \n        @csp.node\n        def passthrough(x: csp.ts[float]) -> csp.ts[float]:\n            if csp.ticked(x):\n                return x\n    \n        @csp.graph\n        def linear_graph():\n            # Create initial timer-based source\n            timer = csp.timer(timedelta(seconds=1), 1.0)\n            current = timer\n    \n            # Chain nodes together\n            for _ in range(num_nodes):\n                current = passthrough(current)\n    \n            csp.add_graph_output(\"output\", current)\n    \n        csp.run(linear_graph, starttime=self.start_time, endtime=self.end_time, realtime=False)\n\n    def setup(self, num_nodes, num_ticks):\n        self.start_time = datetime(2020, 1, 1)\n        self.end_time = self.start_time + timedelta(seconds=num_ticks)", "min_run_count": 2, "name": "bench_core.GraphExecutionSuite.time_linear_graph", "number": 0, "param_names": ["num_nodes", "num_ticks"], "params": [["10", "100", "1000"], ["100", "1000", "10000"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "16f29d60ddd6c1503e096d45daa90600b03c55c0e756ede26db02f1381b61353", "warmup_time": -1}, "bench_core.NodeOverheadSuite.time_compute_node": {"code": "class NodeOverheadSuite:\n    def time_compute_node(self, num_ticks):\n        \"\"\"Measure overhead of a node doing simple computation.\"\"\"\n    \n        @csp.node\n        def compute_node(x: csp.ts[float]) -> csp.ts[float]:\n            if csp.ticked(x):\n                return x * 2.0 + 1.0\n    \n        @csp.graph\n        def graph():\n            timer = csp.timer(timedelta(seconds=1), 1.0)\n            result = compute_node(timer)\n            csp.add_graph_output(\"output\", result)\n    \n        csp.run(graph, starttime=self.start_time, endtime=self.end_time, realtime=False)\n\n    def setup(self, num_ticks):\n        self.start_time = datetime(2020, 1, 1)\n        self.end_time = self.start_time + timedelta(seconds=num_ticks)", "min_run_count": 2, "name": "bench_core.NodeOverheadSuite.time_compute_node", "number": 0, "param_names": ["num_ticks"], "params": [["100", "1000", "10000", "100000"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "858886ca5cb8f2df8500af61e6a2958fb8e5a39519fc294ae26982ea2bd75426", "warmup_time": -1}, "bench_core.NodeOverheadSuite.time_empty_node": {"code": "class NodeOverheadSuite:\n    def time_empty_node(self, num_ticks):\n        \"\"\"Measure overhead of an empty node that just passes data.\"\"\"\n    \n        @csp.node\n        def empty_node(x: csp.ts[float]) -> csp.ts[float]:\n            if csp.ticked(x):\n                return x\n    \n        @csp.graph\n        def graph():\n            timer = csp.timer(timedelta(seconds=1), 1.0)\n            result = empty_node(timer)\n            csp.add_graph_output(\"output\", result)\n    \n        csp.run(graph, starttime=self.start_time, endtime=self.end_time, realtime=False)\n\n    def setup(self, num_ticks):\n        self.start_time = datetime(2020, 1, 1)\n        self.end_time = self.start_time + timedelta(seconds=num_ticks)", "min_run_count": 2, "name": "bench_core.NodeOverheadSuite.time_empty_node", "number": 0, "param_names": ["num_ticks"], "params": [["100", "1000", "10000", "100000"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "53860a566ec08e931f0d20129835d4822466f665d9a5bf88b6350d4b33fce2ce", "warmup_time": -1}, "bench_core.NodeOverheadSuite.time_stateful_node": {"code": "class NodeOverheadSuite:\n    def time_stateful_node(self, num_ticks):\n        \"\"\"Measure overhead of a stateful node.\"\"\"\n    \n        @csp.node\n        def stateful_node(x: csp.ts[float]) -> csp.ts[float]:\n            with csp.state():\n                s_sum = 0.0\n                s_count = 0\n    \n            if csp.ticked(x):\n                s_sum += x\n                s_count += 1\n                return s_sum / s_count\n    \n        @csp.graph\n        def graph():\n            timer = csp.timer(timedelta(seconds=1), 1.0)\n            result = stateful_node(timer)\n            csp.add_graph_output(\"output\", result)\n    \n        csp.run(graph, starttime=self.start_time, endtime=self.end_time, realtime=False)\n\n    def setup(self, num_ticks):\n        self.start_time = datetime(2020, 1, 1)\n        self.end_time = self.start_time + timedelta(seconds=num_ticks)", "min_run_count": 2, "name": "bench_core.NodeOverheadSuite.time_stateful_node", "number": 0, "param_names": ["num_ticks"], "params": [["100", "1000", "10000", "100000"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "895bf6284b54fc326067ff8db4ea65fd0182014598c650ca0579139d40e6e1da", "warmup_time": -1}, "bench_math.AccumulatorSuite.time_accum": {"code": "class AccumulatorSuite:\n    def time_accum(self, num_ticks):\n        \"\"\"Benchmark csp.accum operation.\"\"\"\n    \n        @csp.graph\n        def graph():\n            timer = csp.timer(timedelta(seconds=1), 1.0)\n            accumulated = csp.accum(timer)\n            csp.add_graph_output(\"output\", accumulated)\n    \n        csp.run(graph, starttime=self.start_time, endtime=self.end_time, realtime=False)\n\n    def setup(self, num_ticks):\n        self.start_time = datetime(2020, 1, 1)\n        self.end_time = self.start_time + timedelta(seconds=num_ticks)", "min_run_count": 2, "name": "bench_math.AccumulatorSuite.time_accum", "number": 0, "param_names": ["num_ticks"], "params": [["1000", "10000", "100000"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "053d4fafff0d5f3c5a0c305f83de58514fd6ebbd1f881d3dfbc963dc915c4b45", "warmup_time": -1}, "bench_math.AccumulatorSuite.time_count": {"code": "class AccumulatorSuite:\n    def time_count(self, num_ticks):\n        \"\"\"Benchmark csp.count operation.\"\"\"\n    \n        @csp.graph\n        def graph():\n            timer = csp.timer(timedelta(seconds=1), 1.0)\n            counted = csp.count(timer)\n            csp.add_graph_output(\"output\", counted)\n    \n        csp.run(graph, starttime=self.start_time, endtime=self.end_time, realtime=False)\n\n    def setup(self, num_ticks):\n        self.start_time = datetime(2020, 1, 1)\n        self.end_time = self.start_time + timedelta(seconds=num_ticks)", "min_run_count": 2, "name": "bench_math.AccumulatorSuite.time_count", "number": 0, "param_names": ["num_ticks"], "params": [["1000", "10000", "100000"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "4665223ec8050f277cdca9b40de4a2223a8dc259374c58b69ca8f43d3f95243b", "warmup_time": -1}, "bench_math.AccumulatorSuite.time_diff": {"code": "class AccumulatorSuite:\n    def time_diff(self, num_ticks):\n        \"\"\"Benchmark csp.diff operation.\"\"\"\n    \n        @csp.graph\n        def graph():\n            timer = csp.timer(timedelta(seconds=1), 1.0)\n            accumulated = csp.accum(timer)\n            diffed = csp.diff(accumulated, 1)\n            csp.add_graph_output(\"output\", diffed)\n    \n        csp.run(graph, starttime=self.start_time, endtime=self.end_time, realtime=False)\n\n    def setup(self, num_ticks):\n        self.start_time = datetime(2020, 1, 1)\n        self.end_time = self.start_time + timedelta(seconds=num_ticks)", "min_run_count": 2, "name": "bench_math.AccumulatorSuite.time_diff", "number": 0, "param_names": ["num_ticks"], "params": [["1000", "10000", "100000"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "699e38b1a95f9e1abc3f697ccee00df476b6799a2f6cf5b53366c65c3ce15474", "warmup_time": -1}, "bench_math.MathSuite.time_abs": {"code": "class MathSuite:\n    def time_abs(self, num_ticks):\n        \"\"\"Benchmark csp.abs operation.\"\"\"\n    \n        @csp.graph\n        def graph():\n            timer = csp.timer(timedelta(seconds=1), -1.5)\n            result = abs(timer)\n            csp.add_graph_output(\"output\", result)\n    \n        csp.run(graph, starttime=self.start_time, endtime=self.end_time, realtime=False)\n\n    def setup(self, num_ticks):\n        self.start_time = datetime(2020, 1, 1)\n        self.end_time = self.start_time + timedelta(seconds=num_ticks)", "min_run_count": 2, "name": "bench_math.MathSuite.time_abs", "number": 0, "param_names": ["num_ticks"], "params": [["1000", "10000", "100000"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "58605ed4f7c8d7adfd6a31e81bfb7bbd5df64286dccdae779410f0b03a8d7c13", "warmup_time": -1}, "bench_math.MathSuite.time_arithmetic_chain": {"code": "class MathSuite:\n    def time_arithmetic_chain(self, num_ticks):\n        \"\"\"Benchmark chained arithmetic operations.\"\"\"\n    \n        @csp.graph\n        def graph():\n            t1 = csp.timer(timedelta(seconds=1), 1.0)\n            t2 = csp.timer(timedelta(seconds=1), 2.0)\n            result = (t1 + t2) * t1 - t2 / (t1 + 1)\n            csp.add_graph_output(\"output\", result)\n    \n        csp.run(graph, starttime=self.start_time, endtime=self.end_time, realtime=False)\n\n    def setup(self, num_ticks):\n        self.start_time = datetime(2020, 1, 1)\n        self.end_time = self.start_time + timedelta(seconds=num_ticks)", "min_run_count": 2, "name": "bench_math.MathSuite.time_arithmetic_chain", "number": 0, "param_names": ["num_ticks"], "params": [["1000", "10000", "100000"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "fe40304618e321d9b242a8f9b5086b7f73b6d8bf92366dd042dd88ec4000d666", "warmup_time": -1}, "bench_math.MathSuite.time_comparisons": {"code": "class MathSuite:\n    def time_comparisons(self, num_ticks):\n        \"\"\"Benchmark comparison operations.\"\"\"\n    \n        @csp.graph\n        def graph():\n            t1 = csp.timer(timedelta(seconds=1), 1.0)\n            t2 = csp.timer(timedelta(seconds=1), 2.0)\n            gt = t1 > t2\n            lt = t1 < t2\n            eq = t1 == t2\n            csp.add_graph_output(\"gt\", gt)\n            csp.add_graph_output(\"lt\", lt)\n            csp.add_graph_output(\"eq\", eq)\n    \n        csp.run(graph, starttime=self.start_time, endtime=self.end_time, realtime=False)\n\n    def setup(self, num_ticks):\n        self.start_time = datetime(2020, 1, 1)\n        self.end_time = self.start_time + timedelta(seconds=num_ticks)", "min_run_count": 2, "name": "bench_math.MathSuite.time_comparisons", "number": 0, "param_names": ["num_ticks"], "params": [["1000", "10000", "100000"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "13d0a24117b8584debae36984b7d6a999212d9133c5d5a5f4990cc80f75d5329", "warmup_time": -1}, "bench_stats.StatsBenchmarkSuite.time_stats": {"code": "class StatsBenchmarkSuite:\n    def time_stats(self, function, interval):\n        \"\"\"Time various stats functions.\"\"\"\n    \n        def g():\n            data = csp.curve(typ=np.ndarray, data=self.data)\n            value = getattr(csp.stats, function)(data, interval=self.interval, **self.function_args.get(function, {}))\n            csp.add_graph_output(\"final_value\", value, tick_count=1)\n    \n        csp.run(g, realtime=False, starttime=self.start_date, endtime=timedelta(seconds=self.num_rows))\n\n    def setup(self, function, interval):\n        self.start_date = datetime(2020, 1, 1)\n        self.num_rows = 1_000\n        self.array_size = 100\n        self.test_times = [self.start_date + timedelta(seconds=i) for i in range(self.num_rows)]\n        self.random_values = [np.random.normal(size=(self.array_size,)) for i in range(self.num_rows)]\n        self.data = list(zip(self.test_times, self.random_values))\n        self.interval = interval", "min_run_count": 2, "name": "bench_stats.StatsBenchmarkSuite.time_stats", "number": 0, "param_names": ["function", "interval"], "params": [["'median'", "'quantile'", "'rank'"], ["100", "500", "1000"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "97f646ccd75216b3274a64d0f06e7d065e03195063af9b53d175aa1771145124", "warmup_time": -1}, "bench_stats.StatsScalingSuite.time_mean_scaling": {"code": "class StatsScalingSuite:\n    def time_mean_scaling(self, array_size):\n        \"\"\"Test how mean computation scales with array size.\"\"\"\n    \n        def g():\n            data = csp.curve(typ=np.ndarray, data=self.data)\n            value = csp.stats.mean(data, interval=100)\n            csp.add_graph_output(\"result\", value, tick_count=1)\n    \n        csp.run(g, realtime=False, starttime=self.start_date, endtime=timedelta(seconds=self.num_rows))\n\n    def setup(self, array_size):\n        self.start_date = datetime(2020, 1, 1)\n        self.num_rows = 500\n        self.test_times = [self.start_date + timedelta(seconds=i) for i in range(self.num_rows)]\n        self.random_values = [np.random.normal(size=(array_size,)) for i in range(self.num_rows)]\n        self.data = list(zip(self.test_times, self.random_values))", "min_run_count": 2, "name": "bench_stats.StatsScalingSuite.time_mean_scaling", "number": 0, "param_names": ["array_size"], "params": [["10", "50", "100", "500"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "db48f3b4109436ca651000c3c9c08a2b8aab52916bcd3a47618caa36d659599d", "warmup_time": -1}, "bench_stats.StatsScalingSuite.time_stddev_scaling": {"code": "class StatsScalingSuite:\n    def time_stddev_scaling(self, array_size):\n        \"\"\"Test how stddev computation scales with array size.\"\"\"\n    \n        def g():\n            data = csp.curve(typ=np.ndarray, data=self.data)\n            value = csp.stats.stddev(data, interval=100)\n            csp.add_graph_output(\"result\", value, tick_count=1)\n    \n        csp.run(g, realtime=False, starttime=self.start_date, endtime=timedelta(seconds=self.num_rows))\n\n    def setup(self, array_size):\n        self.start_date = datetime(2020, 1, 1)\n        self.num_rows = 500\n        self.test_times = [self.start_date + timedelta(seconds=i) for i in range(self.num_rows)]\n        self.random_values = [np.random.normal(size=(array_size,)) for i in range(self.num_rows)]\n        self.data = list(zip(self.test_times, self.random_values))", "min_run_count": 2, "name": "bench_stats.StatsScalingSuite.time_stddev_scaling", "number": 0, "param_names": ["array_size"], "params": [["10", "50", "100", "500"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "107661374da486d58d68e9d87d459a178b0a7a4fc9167d5d3eb4f94e5ae4e2c7", "warmup_time": -1}}, "machines": {"timkpaine-mbp-m2": {"arch": "arm64", "cpu": "Apple M2 (8 cores)", "machine": "timkpaine-mbp-m2", "num_cpu": "8", "os": "macOS", "ram": "16GB", "version": 1}, "timkpaine-framework-13": {"arch": "x86_64", "cpu": "AMD Ryzen AI 9 HX 370 (24 cores)", "machine": "timkpaine-framework-13", "num_cpu": "24", "os": "Ubuntu 24.04", "ram": "64GB", "version": 1}}, "tags": {}, "pages": [["", "Grid view", "Display as a agrid"], ["summarylist", "List view", "Display as a list"], ["regressions", "Show regressions", "Display information about recent regressions"]]}